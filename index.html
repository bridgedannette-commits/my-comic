<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" 
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<title>methynecros' Comic Viewer</title>

<link rel="stylesheet" href="css/styles.css">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
<style>
/* ================= LOADING SCREEN ================= */
.loading-screen {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: #111;
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
  opacity: 1;
  transition: opacity 0.5s ease;
}

.loading-screen.hidden {
  opacity: 0;
  pointer-events: none;
}

.loading-content {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 20px;
}

.loading-spinner {
  width: 50px;
  height: 50px;
  border: 4px solid rgba(255, 255, 255, 0.1);
  border-top: 4px solid #FFA500;
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

.loading-text {
  color: #fff;
  font-size: 16px;
  font-family: 'Inter', sans-serif;
  font-weight: 500;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

/* Адаптивность для Loading Screen */
@media (max-width: 768px) {
  .loading-spinner {
    width: 40px;
    height: 40px;
    border-width: 3px;
  }
  
  .loading-text {
    font-size: 14px;
  }
}

@media (max-width: 480px) {
  .loading-spinner {
    width: 30px;
    height: 30px;
    border-width: 3px;
  }
  
  .loading-text {
    font-size: 13px;
  }
}
</style>
</head>

<body>

<!-- Loading Screen -->
<div class="loading-screen" id="loadingScreen">
  <div class="loading-content">
    <div class="loading-spinner"></div>
    <div class="loading-text">Loading comic...</div>
  </div>
</div>

<div class="comic-reader" id="reader">
  <!-- Top panel -->
  <div class="header-wrapper" id="headerWrapper">
    <div class="header">
      <div class="comic-title" id="comicTitle">Loading...</div>
      <div class="header-page-info" id="headerPageInfo">– / –</div>
    </div>
  </div>

  <div class="canvas-wrapper" id="canvasWrapper"></div>

  <!-- Bottom panel -->
  <div class="controls-wrapper" id="controlsWrapper">
    <div class="controls">
      <button id="toTop" class="nav-btn">▲</button>
      <button id="autoScroll" class="nav-btn auto-scroll-btn" title="Autoscroll">▽</button>
      <button id="toBottom" class="nav-btn">▼</button>
    </div>
  </div>

  <!-- Progress bar -->
  <div class="progress">
    <div class="progress-bar" id="progressBar"></div>
  </div>
</div>

<script>
/* ================= URL PARSING ================= */
function getUrlParams() {
  const params = new URLSearchParams(window.location.search);
  const comicId = params.get('comic');
  
  // If comic parameter exists, use it
  if (comicId) {
    return { comicId };
  }
  
  // Otherwise return null (will use first comic from manifest)
  return null;
}

/* ================= CONFIG ================= */
const IMAGE_EXTS = ['webp', 'png', 'jpg', 'jpeg'];
const MAX_PAGES_SAFE = 500;
const isMobile = window.innerWidth <= 768;
const MANIFEST_PATH = 'manifest.json'; // Path to manifest file

/* ================= STATE ================= */
let pages = [];
const wrapper = document.getElementById('canvasWrapper');
const progressBar = document.getElementById('progressBar');
const headerWrapper = document.getElementById('headerWrapper');
const controlsWrapper = document.getElementById('controlsWrapper');
const comicTitle = document.getElementById('comicTitle');
const headerPageInfo = document.getElementById('headerPageInfo');
const reader = document.getElementById('reader');
const loadingScreen = document.getElementById('loadingScreen');

// Timers for hiding panels
let hidePanelsTimeout;
let panelsVisible = true;
const HIDE_PANELS_DELAY = 3000; // 3 seconds before hiding

// Autoscroll
let autoScrollInterval = null;
const AUTO_SCROLL_SPEED = 150; // fixed speed (pixels per second)
let autoScrollActive = false;

/* ================= MANIFEST LOADING ================= */
async function loadManifest() {
  try {
    const response = await fetch(MANIFEST_PATH);
    if (!response.ok) throw new Error(`Failed to load manifest: ${response.status}`);
    const manifest = await response.json();
    
    // Validate manifest structure
    if (!manifest.comics || !Array.isArray(manifest.comics)) {
      throw new Error('Invalid manifest format: missing comics array');
    }
    
    return manifest;
  } catch (error) {
    console.error('Manifest loading error:', error);
    
    // Fallback to default manifest with test comic
    return {
      version: "1.0",
      comics: [
        {
          id: 'test-comic',
          title: 'Test Comic',
          pageCount: 15,
          path: '/my-comic/comics/test/'
        }
      ]
    };
  }
}

async function getComicData() {
  // 1. Load manifest
  const manifest = await loadManifest();
  
  // 2. Get comic ID from URL
  const urlParams = getUrlParams();
  const requestedComicId = urlParams ? urlParams.comicId : null;
  
  // 3. Find comic in manifest
  let comicData;
  
  if (requestedComicId) {
    // Look for requested comic
    comicData = manifest.comics.find(c => c.id === requestedComicId);
    if (!comicData) {
      throw new Error(`Comic "${requestedComicId}" not found in manifest`);
    }
  } else if (manifest.comics.length > 0) {
    // Use first comic as default
    comicData = manifest.comics[0];
  } else {
    throw new Error('No comics available in manifest');
  }
  
  // Validate comic data
  if (!comicData.path) {
    throw new Error('Comic path is missing in manifest');
  }
  
  if (!comicData.pageCount || comicData.pageCount <= 0) {
    throw new Error('Invalid page count in manifest');
  }
  
  // Ensure path ends with slash
  const normalizedPath = comicData.path.endsWith('/') ? comicData.path : comicData.path + '/';
  
  return {
    ...comicData,
    path: normalizedPath
  };
}

/* ================= PANEL FUNCTIONS ================= */
function showPanels() {
  if (!panelsVisible) {
    headerWrapper.classList.remove('hidden');
    controlsWrapper.classList.remove('hidden');
    reader.classList.remove('panels-hidden');
    reader.classList.add('panels-visible');
    panelsVisible = true;
  }
  resetHidePanelsTimer();
}

function hidePanels() {
  if (panelsVisible) {
    headerWrapper.classList.add('hidden');
    controlsWrapper.classList.add('hidden');
    reader.classList.remove('panels-visible');
    reader.classList.add('panels-hidden');
    panelsVisible = false;
  }
}

function resetHidePanelsTimer() {
  clearTimeout(hidePanelsTimeout);
  hidePanelsTimeout = setTimeout(hidePanels, HIDE_PANELS_DELAY);
}

function togglePanels() {
  if (panelsVisible) {
    hidePanels();
  } else {
    showPanels();
  }
}

/* ================= AUTOSCROLL FUNCTIONS ================= */
function startAutoScroll() {
  if (autoScrollInterval) {
    clearInterval(autoScrollInterval);
  }
  
  autoScrollActive = true;
  updateAutoScrollButton();
  
  autoScrollInterval = setInterval(() => {
    const currentScroll = wrapper.scrollTop;
    const maxScroll = wrapper.scrollHeight - wrapper.clientHeight;
    
    // If reached the end, stop autoscroll
    if (currentScroll >= maxScroll - 1) {
      stopAutoScroll();
      return;
    }
    
    // Smooth scroll with fixed speed
    const scrollAmount = AUTO_SCROLL_SPEED / 60; // divide by 60 frames per second
    wrapper.scrollBy({ top: scrollAmount, behavior: 'instant' });
    
    // If reached the end after scrolling
    if (wrapper.scrollTop >= maxScroll - 1) {
      stopAutoScroll();
    }
  }, 1000 / 60); // 60 FPS
}

function stopAutoScroll() {
  if (autoScrollInterval) {
    clearInterval(autoScrollInterval);
    autoScrollInterval = null;
  }
  autoScrollActive = false;
  updateAutoScrollButton();
}

function toggleAutoScroll() {
  if (autoScrollActive) {
    stopAutoScroll();
  } else {
    startAutoScroll();
  }
  showPanels();
}

function updateAutoScrollButton() {
  const autoScrollBtn = document.getElementById('autoScroll');
  if (autoScrollActive) {
    autoScrollBtn.innerHTML = '■';
    autoScrollBtn.classList.add('active');
    autoScrollBtn.title = 'Autoscroll - click to stop';
  } else {
    autoScrollBtn.innerHTML = '▽';
    autoScrollBtn.classList.remove('active');
    autoScrollBtn.title = 'Autoscroll - click to start';
  }
}

/* ================= IMAGE LOADING ================= */
async function imageExists(url) {
  try {
    const res = await fetch(url, { method: 'HEAD', cache: 'no-store' });
    return res.ok;
  } catch {
    return false;
  }
}

async function detectPages(comicPath, pageCount) {
  const result = [];
  
  // First, try to use the pageCount from manifest
  for (let pageNum = 1; pageNum <= pageCount; pageNum++) {
    let found = false;
    
    for (const ext of IMAGE_EXTS) {
      const url = `${comicPath}${pageNum}.${ext}`;
      if (await imageExists(url)) {
        result.push({ url, num: pageNum });
        found = true;
        break;
      }
    }
    
    // If no image found for this page number, stop
    if (!found) {
      console.warn(`Page ${pageNum} not found, stopping detection`);
      break;
    }
  }
  
  // If no pages found with manifest pageCount, try auto-detection
  if (result.length === 0) {
    console.log('Trying auto-detection...');
    let pageNum = 1;
    
    while (pageNum <= MAX_PAGES_SAFE) {
      let found = false;

      for (const ext of IMAGE_EXTS) {
        const url = `${comicPath}${pageNum}.${ext}`;
        if (await imageExists(url)) {
          result.push({ url, num: pageNum });
          found = true;
          break;
        }
      }

      if (!found) break;
      pageNum++;
    }
  }
  
  return result;
}

async function loadComic() {
  // Show loading screen
  loadingScreen.classList.remove('hidden');
  
  try {
    // 1. Get comic data from manifest
    const comicData = await getComicData();
    
    // 2. Update title
    comicTitle.textContent = comicData.title;
    document.title = `${comicData.title} - Comic Viewer`;
    
    // 3. Show initial loading message
    wrapper.innerHTML = '<div style="color:#ccc;text-align:center;padding:50px;">Loading pages...</div>';
    
    // 4. Detect and load pages
    pages = await detectPages(comicData.path, comicData.pageCount);
    
    if (pages.length === 0) {
      throw new Error(`No images found at path: ${comicData.path}`);
    }
    
    // 5. Clear and create page containers
    wrapper.innerHTML = '';
    
    pages.forEach((page, index) => {
      const container = document.createElement('div');
      container.className = 'page-container';
      container.dataset.page = page.num;
      container.style.margin = '0 auto';
      
      const img = document.createElement('img');
      img.loading = 'lazy';
      img.draggable = false;
      img.alt = `Page ${page.num}`;
      img.style.display = 'block';
      img.style.margin = '0 auto';
      img.style.maxWidth = '100%';
      img.style.height = 'auto';
      
      // Auto size
      img.onload = function() {
        const maxWidth = isMobile ? 
          Math.min(800, window.innerWidth - 20) : 
          Math.min(1000, window.innerWidth * 0.95);
        
        if (this.naturalWidth > maxWidth) {
          const scale = maxWidth / this.naturalWidth;
          this.style.width = maxWidth + 'px';
          this.style.height = (this.naturalHeight * scale) + 'px';
          container.style.width = maxWidth + 'px';
        } else {
          this.style.width = this.naturalWidth + 'px';
          container.style.width = this.naturalWidth + 'px';
        }
      };
      
      // Lazy load: first 5 images load immediately, others use data-src
      if (index < 5) {
        img.src = page.url;
      } else {
        img.dataset.src = page.url;
      }
      
      container.appendChild(img);
      wrapper.appendChild(container);
    });
    
    // 6. Initialize panel state
    reader.classList.add('panels-visible');
    
    updatePageInfo();
    
    // 7. Wait for all images to load
    const images = wrapper.querySelectorAll('img');
    let loadedCount = 0;
    
    if (images.length === 0) {
      setTimeout(() => {
        loadingScreen.classList.add('hidden');
      }, 300);
    } else {
      images.forEach(img => {
        if (img.complete) {
          loadedCount++;
          checkAllImagesLoaded(loadedCount, images.length);
        } else {
          img.addEventListener('load', () => {
            loadedCount++;
            checkAllImagesLoaded(loadedCount, images.length);
          });
          img.addEventListener('error', () => {
            loadedCount++;
            checkAllImagesLoaded(loadedCount, images.length);
          });
        }
      });
    }
    
    // 8. Load remaining images
    setTimeout(() => {
      wrapper.querySelectorAll('img[data-src]').forEach(img => {
        img.src = img.dataset.src;
        delete img.dataset.src;
      });
    }, 100);
    
  } catch (error) {
    console.error('Comic loading error:', error);
    
    wrapper.innerHTML = `<div style="color:#fff;text-align:center;padding:50px;">
      <h3>Error loading comic</h3>
      <p style="color:#ccc;margin:10px 0;">${error.message}</p>
      <p><a href="?" style="color:#FFA500;">Return to comics list</a></p>
    </div>`;
    
    setTimeout(() => {
      loadingScreen.classList.add('hidden');
    }, 500);
  }
}

function checkAllImagesLoaded(loaded, total) {
  if (loaded === total) {
    setTimeout(() => {
      loadingScreen.classList.add('hidden');
    }, 300);
  }
}

/* ================= NAVIGATION ================= */
function getCurrentPage() {
  const containers = wrapper.querySelectorAll('.page-container');
  if (containers.length === 0) return 1;
  
  const wrapperRect = wrapper.getBoundingClientRect();
  const wrapperCenter = wrapperRect.top + wrapperRect.height / 2;
  
  let currentPage = 1;
  let minDistance = Infinity;
  
  containers.forEach(container => {
    const rect = container.getBoundingClientRect();
    const containerCenter = rect.top + rect.height / 2;
    const distance = Math.abs(containerCenter - wrapperCenter);
    
    if (distance < minDistance) {
      minDistance = distance;
      currentPage = parseInt(container.dataset.page) || 1;
    }
  });
  
  return currentPage;
}

function updatePageInfo() {
  const current = getCurrentPage();
  headerPageInfo.textContent = `${current} / ${pages.length}`;
}

function updateScrollInfo() {
  const scrollHeight = wrapper.scrollHeight - wrapper.clientHeight;
  if (scrollHeight > 0) {
    const progress = (wrapper.scrollTop / scrollHeight) * 100;
    progressBar.style.width = progress + '%';
  }
  updatePageInfo();
}

/* ================= EVENTS ================= */
document.getElementById('toTop').onclick = () => {
  wrapper.scrollTo({ top: 0, behavior: 'smooth' });
  stopAutoScroll(); // Stop autoscroll on navigation
  showPanels();
};

document.getElementById('toBottom').onclick = () => {
  wrapper.scrollTo({ top: wrapper.scrollHeight, behavior: 'smooth' });
  stopAutoScroll(); // Stop autoscroll on navigation
  showPanels();
};

document.getElementById('autoScroll').onclick = () => {
  toggleAutoScroll();
};

// Click on comic area shows/hides panels (does NOT stop autoscroll)
wrapper.addEventListener('click', (e) => {
  // Don't respond to clicks on buttons and other interactive elements
  if (e.target.tagName === 'BUTTON' || e.target.closest('button')) {
    return;
  }
  
  // Don't respond to clicks on progress bar
  if (e.target.closest('.progress')) {
    return;
  }
  
  togglePanels();
});

// Tap on mobile devices (for touch devices)
wrapper.addEventListener('touchstart', (e) => {
  // Save starting tap point
  e.tapStartX = e.touches[0].clientX;
  e.tapStartY = e.touches[0].clientY;
  e.isTap = true;
}, { passive: true });

wrapper.addEventListener('touchmove', (e) => {
  // If finger moved more than 10px - it's not a tap, but a swipe
  const touch = e.touches[0];
  const diffX = Math.abs(touch.clientX - e.tapStartX);
  const diffY = Math.abs(touch.clientY - e.tapStartY);
  
  if (diffX > 10 || diffY > 10) {
    e.isTap = false;
  }
}, { passive: true });

wrapper.addEventListener('touchend', (e) => {
  // If it was a tap (not swipe) - show/hide panels
  if (e.isTap) {
    // Don't respond to taps on buttons
    const target = e.target;
    if (target.tagName === 'BUTTON' || target.closest('button')) {
      return;
    }
    
    // Don't respond to taps on progress bar
    if (target.closest('.progress')) {
      return;
    }
    
    togglePanels();
    e.preventDefault();
  }
}, { passive: false });

// On mouse wheel scroll - do NOT show panels, only update progress
let scrollTimeout;
wrapper.addEventListener('scroll', () => {
  const scrollHeight = wrapper.scrollHeight - wrapper.clientHeight;
  if (scrollHeight > 0) {
    const progress = (wrapper.scrollTop / scrollHeight) * 100;
    progressBar.style.width = progress + '%';
  }
  
  clearTimeout(scrollTimeout);
  scrollTimeout = setTimeout(updatePageInfo, 50);
}, { passive: true });

// Window resize
let resizeTimeout;
window.addEventListener('resize', () => {
  clearTimeout(resizeTimeout);
  resizeTimeout = setTimeout(() => {
    const maxWidth = isMobile ? 
      Math.min(800, window.innerWidth - 20) : 
      Math.min(1000, window.innerWidth * 0.95);
    
    wrapper.querySelectorAll('img').forEach(img => {
      if (img.naturalWidth) {
        if (img.naturalWidth > maxWidth) {
          const scale = maxWidth / img.naturalWidth;
          img.style.width = maxWidth + 'px';
          img.style.height = (img.naturalHeight * scale) + 'px';
          
          const container = img.parentElement;
          if (container) {
            container.style.width = maxWidth + 'px';
          }
        }
      }
    });
    
    updatePageInfo();
  }, 250);
});

// Keyboard
document.addEventListener('keydown', (e) => {
  switch(e.key) {
    case 'ArrowDown':
    case 'PageDown':
    case ' ':
      e.preventDefault();
      wrapper.scrollBy({ top: wrapper.clientHeight * 0.8, behavior: 'smooth' });
      stopAutoScroll(); // Stop autoscroll on manual navigation
      break;
    case 'ArrowUp':
    case 'PageUp':
      e.preventDefault();
      wrapper.scrollBy({ top: -wrapper.clientHeight * 0.8, behavior: 'smooth' });
      stopAutoScroll(); // Stop autoscroll on manual navigation
      break;
    case 'Home':
      e.preventDefault();
      wrapper.scrollTo({ top: 0, behavior: 'smooth' });
      stopAutoScroll();
      break;
    case 'End':
      e.preventDefault();
      wrapper.scrollTo({ top: wrapper.scrollHeight, behavior: 'smooth' });
      stopAutoScroll();
      break;
    case 'a':
    case 'A':
      // Key A to toggle autoscroll
      e.preventDefault();
      toggleAutoScroll();
      break;
    case 'f':
    case 'F':
      // Key F to toggle panel visibility
      e.preventDefault();
      togglePanels();
      break;
  }
});

// Hide panels on inactivity
resetHidePanelsTimer();

/* ================= INITIALIZATION ================= */
document.addEventListener('DOMContentLoaded', () => {
  // Fix for mobile
  if (/iPhone|iPad|iPod/i.test(navigator.userAgent)) {
    document.documentElement.style.height = '-webkit-fill-available';
    document.getElementById('reader').style.height = '-webkit-fill-available';
  }
  
  // Block page scroll
  document.documentElement.style.overflow = 'hidden';
  document.body.style.overflow = 'hidden';
  
  // Load comic with manifest support
  loadComic();
});

// After full load
window.addEventListener('load', () => {
  setTimeout(updatePageInfo, 100);
});

// Hide loading screen after 10 seconds maximum (just in case)
setTimeout(() => {
  if (loadingScreen && !loadingScreen.classList.contains('hidden')) {
    loadingScreen.classList.add('hidden');
  }
}, 10000);
</script>
</body>
</html>
