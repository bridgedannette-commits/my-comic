<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<meta name="viewport" 
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<title>Комикс</title>

<link rel="stylesheet" href="css/styles.css">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
<style>
  /* Дополнительные стили для фиксов */
  .page-container {
    display: flex;
    justify-content: center;
    align-items: flex-start;
    margin: 0 auto;
    padding: 0;
    position: relative;
    transition: transform 0.1s ease;
  }
  
  .page-container img {
    display: block;
    max-width: 100%;
    height: auto;
    image-rendering: -webkit-optimize-contrast;
    image-rendering: crisp-edges;
  }
  
  /* Фикс для controls-wrapper */
  .controls-wrapper {
    pointer-events: auto !important; /* ВАЖНО: переопределяем */
  }
  
  /* Гарантируем видимость кнопок на мобильных */
  @media (max-width: 768px) {
    .controls {
      opacity: 1 !important;
      visibility: visible !important;
      display: flex !important;
    }
    
    .controls-wrapper {
      opacity: 1 !important;
      visibility: visible !important;
    }
  }
</style>
</head>

<body>

<div class="comic-reader" id="reader">
  <div class="canvas-wrapper" id="canvasWrapper">
    <!-- Страницы будут добавляться сюда -->
  </div>

  <div class="zoom-indicator" id="zoomIndicator">
    <span id="zoomPercent">100%</span>
  </div>

  <div class="controls-wrapper" id="controlsWrapper">
    <div class="controls" id="controls">
      <button id="toTop" title="В начало">▲</button>
      <button id="zoomOut" title="Уменьшить">−</button>
      <span id="pageInfo">– / –</span>
      <button id="zoomIn" title="Увеличить">+</button>
      <button id="toBottom" title="В конец">▼</button>
    </div>
  </div>

  <div class="progress">
    <div class="progress-bar" id="progressBar"></div>
  </div>
</div>

<script>
/* ======================================================
   КОНФИГУРАЦИЯ
====================================================== */
const COMIC_PATH = 'https://bridgedannette-commits.github.io/my-comic/comics/test/';
const IMAGE_EXTS = ['webp', 'png', 'jpg', 'jpeg'];
const MAX_PAGES_SAFE = 500;

const MIN_ZOOM = 0.5;
const MAX_ZOOM = 3.0;
const ZOOM_STEP = 0.2;

const isMobile = window.innerWidth <= 768;
const isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);

/* ======================================================
   СОСТОЯНИЕ
====================================================== */
let zoom = 1.0;
let pages = [];
let images = [];
let baseWidth = 600;
let lastTap = { x: 0, y: 0, time: 0 };

const wrapper = document.getElementById('canvasWrapper');
const controlsWrapper = document.getElementById('controlsWrapper');
const pageInfo = document.getElementById('pageInfo');
const progressBar = document.getElementById('progressBar');
const zoomIndicator = document.getElementById('zoomIndicator');
const zoomPercent = document.getElementById('zoomPercent');

/* ======================================================
   ОСНОВНЫЕ ФУНКЦИИ
====================================================== */

// Проверка существования изображения
async function imageExists(url) {
  try {
    const res = await fetch(url, { method: 'HEAD', cache: 'no-store' });
    return res.ok;
  } catch {
    return false;
  }
}

// Поиск всех страниц
async function detectPages() {
  const result = [];
  let pageNum = 1;

  while (pageNum <= MAX_PAGES_SAFE) {
    let found = false;

    for (const ext of IMAGE_EXTS) {
      const url = `${COMIC_PATH}${pageNum}.${ext}`;
      if (await imageExists(url)) {
        result.push({ url, num: pageNum, ext });
        found = true;
        break;
      }
    }

    if (!found) break;
    pageNum++;
  }

  return result;
}

// Загрузка комикса
async function loadComic() {
  wrapper.innerHTML = '<div style="color:#ccc;text-align:center;padding:50px;font-family:Inter,sans-serif;">Загрузка...</div>';
  
  pages = await detectPages();
  
  if (pages.length === 0) {
    wrapper.innerHTML = '<div style="color:#fff;text-align:center;padding:50px;font-family:Inter,sans-serif;">Комикс не найден</div>';
    return;
  }
  
  wrapper.innerHTML = '';
  images = new Array(pages.length);
  
  // Создаем контейнеры для всех страниц сразу
  pages.forEach((page, index) => {
    const pageDiv = document.createElement('div');
    pageDiv.className = 'page-container';
    pageDiv.id = `page-${page.num}`;
    pageDiv.style.margin = '0 auto';
    pageDiv.style.padding = '0';
    
    const img = document.createElement('img');
    img.loading = 'lazy';
    img.draggable = false;
    img.alt = `Страница ${page.num}`;
    img.style.display = 'block';
    img.style.margin = '0';
    img.style.padding = '0';
    img.style.width = 'auto';
    img.style.height = 'auto';
    img.style.maxWidth = '100%';
    
    if (index < 3) {
      img.src = page.url;
    } else {
      img.dataset.src = page.url;
    }
    
    img.onload = function() {
      images[index] = this;
      applyZoomToImage(this, false);
    };
    
    pageDiv.appendChild(img);
    wrapper.appendChild(pageDiv);
  });
  
  updatePageInfo();
  calculateBaseWidth();
  applyZoomToAll(false);
  
  // Принудительно показываем кнопки
  if (controlsWrapper) {
    controlsWrapper.style.opacity = '1';
    controlsWrapper.style.visibility = 'visible';
    controlsWrapper.style.pointerEvents = 'auto';
  }
  
  // Загружаем остальные изображения
  setTimeout(() => loadRemainingImages(), 100);
}

// Загрузка оставшихся изображений
function loadRemainingImages() {
  const imgs = wrapper.querySelectorAll('img[data-src]');
  imgs.forEach(img => {
    img.src = img.dataset.src;
    delete img.dataset.src;
  });
}

// Вычисление базовой ширины
function calculateBaseWidth() {
  if (isMobile) {
    baseWidth = Math.min(800, window.innerWidth - 20);
  } else {
    baseWidth = Math.min(1000, window.innerWidth * 0.9);
  }
}

/* ======================================================
   МАСШТАБИРОВАНИЕ (ИСПРАВЛЕННОЕ С ЦЕНТРИРОВАНИЕМ)
====================================================== */

// Применяем зум к одному изображению
function applyZoomToImage(img, preservePosition = true) {
  if (!img.naturalWidth) return;
  
  const naturalWidth = img.naturalWidth;
  const naturalHeight = img.naturalHeight;
  const displayWidth = Math.floor(baseWidth * zoom);
  const scale = displayWidth / naturalWidth;
  const displayHeight = Math.floor(naturalHeight * scale);
  
  const oldWidth = parseInt(img.style.width) || naturalWidth;
  const oldHeight = parseInt(img.style.height) || naturalHeight;
  
  img.style.width = displayWidth + 'px';
  img.style.height = displayHeight + 'px';
  
  const container = img.parentElement;
  if (container) {
    container.style.width = displayWidth + 'px';
    container.style.height = displayHeight + 'px';
  }
  
  return { oldWidth, oldHeight, displayWidth, displayHeight };
}

// Применяем зум ко всем изображениям с сохранением позиции
function applyZoomToAll(preserveScrollPosition = true) {
  if (preserveScrollPosition) {
    // Сохраняем текущую видимую область
    const scrollTop = wrapper.scrollTop;
    const scrollLeft = wrapper.scrollLeft;
    const centerElement = getElementAtCenter();
    
    calculateBaseWidth();
    const displayWidth = Math.floor(baseWidth * zoom);
    
    images.forEach((img, index) => {
      if (img && img.naturalWidth) {
        applyZoomToImage(img, true);
      }
    });
    
    // Восстанавливаем позицию через requestAnimationFrame
    requestAnimationFrame(() => {
      if (centerElement) {
        // Центрируем элемент, который был в центре
        centerElement.scrollIntoView({ block: 'center', behavior: 'instant' });
      } else {
        // Или восстанавливаем позицию прокрутки
        wrapper.scrollTop = scrollTop * (zoom / (zoom - ZOOM_STEP));
      }
    });
  } else {
    calculateBaseWidth();
    images.forEach(img => {
      if (img && img.naturalWidth) {
        applyZoomToImage(img, false);
      }
    });
  }
  
  showZoomIndicator();
}

// Получить элемент в центре экрана
function getElementAtCenter() {
  const wrapperRect = wrapper.getBoundingClientRect();
  const centerY = wrapperRect.top + wrapperRect.height / 2;
  
  let closestElement = null;
  let minDistance = Infinity;
  
  wrapper.querySelectorAll('.page-container').forEach(container => {
    const rect = container.getBoundingClientRect();
    const center = rect.top + rect.height / 2;
    const distance = Math.abs(center - centerY);
    
    if (distance < minDistance) {
      minDistance = distance;
      closestElement = container;
    }
  });
  
  return closestElement;
}

// Изменение зума с центрированием по точке
function changeZoom(delta, centerX = null, centerY = null) {
  const newZoom = zoom + delta;
  
  if (newZoom < MIN_ZOOM || newZoom > MAX_ZOOM) {
    return;
  }
  
  // Если есть точка центра (для тапа/щипка)
  if (centerX !== null && centerY !== null && isMobile) {
    zoomAtPoint(newZoom, centerX, centerY);
    return;
  }
  
  const oldZoom = zoom;
  zoom = Math.round(newZoom * 100) / 100;
  
  // Сохраняем текущий скролл перед изменением
  const scrollTop = wrapper.scrollTop;
  const scrollHeight = wrapper.scrollHeight;
  const clientHeight = wrapper.clientHeight;
  
  applyZoomToAll(true);
  
  // Плавное восстановление позиции
  requestAnimationFrame(() => {
    const newScrollHeight = wrapper.scrollHeight;
    if (scrollHeight > 0 && newScrollHeight > 0) {
      const scrollRatio = scrollTop / scrollHeight;
      wrapper.scrollTop = newScrollHeight * scrollRatio;
    }
  });
}

// Зум в конкретной точке (для мобильных)
function zoomAtPoint(newZoom, centerX, centerY) {
  const oldZoom = zoom;
  
  // Координаты относительно wrapper
  const wrapperRect = wrapper.getBoundingClientRect();
  const pointX = centerX - wrapperRect.left + wrapper.scrollLeft;
  const pointY = centerY - wrapperRect.top + wrapper.scrollTop;
  
  // Сохраняем соотношение точки до зума
  const pointRatioX = pointX / wrapper.scrollWidth;
  const pointRatioY = pointY / wrapper.scrollHeight;
  
  zoom = Math.round(newZoom * 100) / 100;
  applyZoomToAll(false);
  
  // Восстанавливаем позицию так, чтобы точка осталась на месте
  requestAnimationFrame(() => {
    const newScrollLeft = pointRatioX * wrapper.scrollWidth - (centerX - wrapperRect.left);
    const newScrollTop = pointRatioY * wrapper.scrollHeight - (centerY - wrapperRect.top);
    
    wrapper.scrollTo({
      left: Math.max(0, newScrollLeft),
      top: Math.max(0, newScrollTop),
      behavior: 'smooth'
    });
  });
}

// Показать индикатор зума
function showZoomIndicator() {
  zoomPercent.textContent = Math.round(zoom * 100) + '%';
  zoomIndicator.classList.add('visible');
  
  clearTimeout(zoomIndicator.timeout);
  zoomIndicator.timeout = setTimeout(() => {
    zoomIndicator.classList.remove('visible');
  }, 1500);
}

/* ======================================================
   НАВИГАЦИЯ
====================================================== */

function getCurrentPage() {
  const pageContainers = wrapper.querySelectorAll('.page-container');
  if (pageContainers.length === 0) return 1;
  
  const wrapperRect = wrapper.getBoundingClientRect();
  const wrapperCenter = wrapperRect.top + wrapperRect.height / 2;
  
  let currentPage = 1;
  let minDistance = Infinity;
  
  pageContainers.forEach((container, index) => {
    const rect = container.getBoundingClientRect();
    const containerCenter = rect.top + rect.height / 2;
    const distance = Math.abs(containerCenter - wrapperCenter);
    
    if (distance < minDistance) {
      minDistance = distance;
      currentPage = index + 1;
    }
  });
  
  return currentPage;
}

function updatePageInfo() {
  const current = getCurrentPage();
  pageInfo.textContent = `${current} / ${pages.length}`;
}

/* ======================================================
   ОБРАБОТЧИКИ СОБЫТИЙ (ИСПРАВЛЕННЫЕ)
====================================================== */

function setupEventListeners() {
  // Кнопки зума
  document.getElementById('zoomIn').onclick = () => changeZoom(ZOOM_STEP);
  document.getElementById('zoomOut').onclick = () => changeZoom(-ZOOM_STEP);
  
  // Навигация
  document.getElementById('toTop').onclick = () => {
    wrapper.scrollTo({ top: 0, behavior: 'smooth' });
  };
  
  document.getElementById('toBottom').onclick = () => {
    wrapper.scrollTo({ top: wrapper.scrollHeight, behavior: 'smooth' });
  };
  
  // Плавный скролл
  let scrollTimeout;
  wrapper.addEventListener('scroll', () => {
    const scrollHeight = wrapper.scrollHeight - wrapper.clientHeight;
    if (scrollHeight > 0) {
      const progress = (wrapper.scrollTop / scrollHeight) * 100;
      progressBar.style.width = progress + '%';
    }
    
    clearTimeout(scrollTimeout);
    scrollTimeout = setTimeout(updatePageInfo, 50);
  }, { passive: true });
  
  // Ресайз окна
  let resizeTimeout;
  window.addEventListener('resize', () => {
    clearTimeout(resizeTimeout);
    resizeTimeout = setTimeout(() => {
      calculateBaseWidth();
      applyZoomToAll(false);
      updatePageInfo();
    }, 250);
  });
  
  // Тач-события для мобильных
  if (isMobile) {
    setupTouchEvents();
  }
  
  // Клавиатура для десктопа
  if (!isMobile) {
    document.addEventListener('keydown', handleKeydown);
  }
}

// Настройка тач-событий с зумом по точке
function setupTouchEvents() {
  let touchStartDistance = 0;
  let touchStartZoom = zoom;
  let initialTouches = [];
  
  // Двойной тап для зума в точке тапа
  wrapper.addEventListener('touchend', (e) => {
    const currentTime = Date.now();
    const touch = e.changedTouches[0];
    
    if (currentTime - lastTap.time < 300 &&
        Math.abs(touch.clientX - lastTap.x) < 50 &&
        Math.abs(touch.clientY - lastTap.y) < 50) {
      e.preventDefault();
      
      // Переключаем между 100% и 150% с центрированием по точке тапа
      if (Math.abs(zoom - 1.0) < 0.1) {
        changeZoom(0.5, touch.clientX, touch.clientY);
      } else {
        changeZoom(-0.5, touch.clientX, touch.clientY);
      }
    }
    
    lastTap = {
      x: touch.clientX,
      y: touch.clientY,
      time: currentTime
    };
  }, { passive: false });
  
  // Щипок для зума
  wrapper.addEventListener('touchstart', (e) => {
    if (e.touches.length === 2) {
      initialTouches = [e.touches[0], e.touches[1]];
      touchStartDistance = getTouchDistance(initialTouches);
      touchStartZoom = zoom;
    }
  }, { passive: true });
  
  wrapper.addEventListener('touchmove', (e) => {
    if (e.touches.length === 2) {
      e.preventDefault();
      
      const currentDistance = getTouchDistance(e.touches);
      const centerX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
      const centerY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
      
      const scale = currentDistance / touchStartDistance;
      const newZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, touchStartZoom * scale));
      
      if (Math.abs(newZoom - zoom) > 0.05) {
        zoom = newZoom;
        applyZoomToAll(false);
        
        // Центрируем по средней точке щипка
        const wrapperRect = wrapper.getBoundingClientRect();
        const pointX = centerX - wrapperRect.left + wrapper.scrollLeft;
        const pointY = centerY - wrapperRect.top + wrapper.scrollTop;
        
        const pointRatioX = pointX / wrapper.scrollWidth;
        const pointRatioY = pointY / wrapper.scrollHeight;
        
        requestAnimationFrame(() => {
          const newScrollLeft = pointRatioX * wrapper.scrollWidth - (centerX - wrapperRect.left);
          const newScrollTop = pointRatioY * wrapper.scrollHeight - (centerY - wrapperRect.top);
          
          wrapper.scrollLeft = Math.max(0, newScrollLeft);
          wrapper.scrollTop = Math.max(0, newScrollTop);
        });
      }
    }
  }, { passive: false });
  
  wrapper.addEventListener('touchend', () => {
    if (initialTouches.length > 0) {
      showZoomIndicator();
      initialTouches = [];
    }
  }, { passive: true });
}

// Расстояние между двумя касаниями
function getTouchDistance(touches) {
  const dx = touches[0].clientX - touches[1].clientX;
  const dy = touches[0].clientY - touches[1].clientY;
  return Math.sqrt(dx * dx + dy * dy);
}

// Обработка клавиатуры
function handleKeydown(e) {
  if (e.ctrlKey || e.metaKey) {
    if (e.key === '+' || e.key === '=') {
      e.preventDefault();
      changeZoom(ZOOM_STEP);
      return;
    }
    if (e.key === '-') {
      e.preventDefault();
      changeZoom(-ZOOM_STEP);
      return;
    }
    if (e.key === '0') {
      e.preventDefault();
      zoom = 1.0;
      applyZoomToAll(true);
      return;
    }
  }
  
  switch(e.key) {
    case 'ArrowDown':
    case 'PageDown':
    case ' ':
      e.preventDefault();
      wrapper.scrollBy({ top: wrapper.clientHeight * 0.8, behavior: 'smooth' });
      break;
    case 'ArrowUp':
    case 'PageUp':
      e.preventDefault();
      wrapper.scrollBy({ top: -wrapper.clientHeight * 0.8, behavior: 'smooth' });
      break;
    case 'Home':
      e.preventDefault();
      wrapper.scrollTo({ top: 0, behavior: 'smooth' });
      break;
    case 'End':
      e.preventDefault();
      wrapper.scrollTo({ top: wrapper.scrollHeight, behavior: 'smooth' });
      break;
  }
}

/* ======================================================
   ИНИЦИАЛИЗАЦИЯ
====================================================== */

document.addEventListener('DOMContentLoaded', () => {
  // Фикс для мобильных браузеров
  if (isIOS) {
    document.documentElement.style.height = '-webkit-fill-available';
    const reader = document.getElementById('reader');
    reader.style.height = '-webkit-fill-available';
  }
  
  // Блокируем скролл страницы
  document.documentElement.style.overflow = 'hidden';
  document.body.style.overflow = 'hidden';
  
  // Фикс для кнопок
  if (controlsWrapper) {
    controlsWrapper.style.pointerEvents = 'auto';
    controlsWrapper.style.opacity = '1';
    controlsWrapper.style.visibility = 'visible';
  }
  
  // Загружаем комикс
  loadComic().then(() => {
    setupEventListeners();
  });
  
  // Ресайз при повороте
  window.addEventListener('orientationchange', () => {
    setTimeout(() => {
      calculateBaseWidth();
      applyZoomToAll(false);
    }, 300);
  });
});

// Фикс после полной загрузки
window.addEventListener('load', () => {
  setTimeout(() => {
    calculateBaseWidth();
    applyZoomToAll(false);
  }, 100);
});
</script>

</body>
</html>
