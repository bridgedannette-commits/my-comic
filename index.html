<div class="comic-reader" id="reader">
  <div class="canvas-wrapper" id="canvasWrapper"></div>

  <!-- Индикатор масштаба над панелью -->
  <div class="zoom-indicator" id="zoomIndicator">
    <span id="zoomPercent">100%</span>
  </div>

  <div class="controls-wrapper">
    <div class="controls" id="controls">
      <button id="toTop" title="В начало" class="nav-btn">▲</button>
      <button id="zoomOut" title="Уменьшить" class="zoom-btn">−</button>
      <span id="pageInfo">– / –</span>
      <button id="zoomIn" title="Увеличить" class="zoom-btn">+</button>
      <button id="toBottom" title="В конец" class="nav-btn">▼</button>
    </div>
  </div>

  <div class="progress">
    <div class="progress-bar" id="progressBar"></div>
  </div>
</div>

<!-- Подключаем CSS файл -->
<link rel="stylesheet" href="css/styles.css">

<!-- Подключаем современный шрифт без засечек -->
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">

<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
<script>
// Устанавливаем worker
pdfjsLib.GlobalWorkerOptions.workerSrc =
  "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";

const PDF_URL = "https://bridgedannette-commits.github.io/my-comic/comics/mycomic.pdf";

let pdfDoc = null;
let zoom = 1.0;
const MIN_ZOOM = 0.5;
const MAX_ZOOM = 3.0;
const ZOOM_STEP = 0.2;

let currentRenderId = 0;
let zoomIndicatorTimeout = null;

const wrapper = document.getElementById("canvasWrapper");
const pageInfo = document.getElementById("pageInfo");
const progressBar = document.getElementById("progressBar");
const zoomIndicator = document.getElementById("zoomIndicator");
const zoomPercent = document.getElementById("zoomPercent");
const zoomInBtn = document.getElementById("zoomIn");
const zoomOutBtn = document.getElementById("zoomOut");
const toTopBtn = document.getElementById("toTop");
const toBottomBtn = document.getElementById("toBottom");
const reader = document.getElementById("reader");

const canvases = [];

// Инициализация PDF
async function initPDF() {
  try {
    wrapper.innerHTML = '<div style="color: #ccc; text-align: center; padding: 50px; font-size: 16px; font-family: \'Inter\', sans-serif;">Загрузка комикса...</div>';
    
    pdfDoc = await pdfjsLib.getDocument(PDF_URL).promise;
    
    wrapper.innerHTML = '';
    
    pageInfo.textContent = `1 / ${pdfDoc.numPages}`;
    
    for (let i = 1; i <= pdfDoc.numPages; i++) {
      const canvas = document.createElement("canvas");
      canvas.id = `page-${i}`;
      canvas.className = 'pdf-page';
      wrapper.appendChild(canvas);
      canvases.push(canvas);
    }
    
    await renderAllPages();
    setTimeout(async () => {
       if (pdfDoc) {
           await renderPage(1, currentRenderId);
    }
}, 1000);
    setupEventListeners();
    
    // Устанавливаем комикс на всю страницу
    document.documentElement.style.overflow = 'hidden';
    document.body.style.overflow = 'hidden';
    
  } catch (error) {
    console.error("Ошибка загрузки PDF:", error);
    wrapper.innerHTML = '<div style="color: #fff; text-align: center; padding: 50px; font-size: 16px; font-family: \'Inter\', sans-serif;">Ошибка загрузки комикса</div>';
  }
}

// Получаем целевую ширину
function getTargetWidth() {
    return Math.min(600, window.innerWidth * 0.9);
}

// Рендерим одну страницу - ПРОСТАЯ ВЕРСИЯ КАК В РАБОЧЕМ КОДЕ
// Рендерим одну страницу с фиксом для всех повернутых страниц
async function renderPage(pageNum, renderId) {
  if (!pdfDoc || renderId !== currentRenderId) return;
  
  const page = await pdfDoc.getPage(pageNum);
  const canvas = canvases[pageNum - 1];
  const ctx = canvas.getContext("2d");
  
  const viewport = page.getViewport({ scale: 1 });
  const targetWidth = getTargetWidth();
  const baseScale = targetWidth / viewport.width;
  const finalScale = baseScale * zoom;
  
  // ВАЖНО: игнорируем rotation из PDF для всех страниц
  // Принудительно ставим rotation = 0
  const scaledViewport = page.getViewport({ 
    scale: finalScale,
    rotation: 0 // Всегда без поворота
  });
  
  canvas.width = scaledViewport.width;
  canvas.height = scaledViewport.height;
  canvas.style.width = `${scaledViewport.width}px`;
  canvas.style.height = `${scaledViewport.height}px`;
  canvas.style.margin = '0 auto';
  canvas.style.display = 'block';
  
  const renderContext = {
    canvasContext: ctx,
    viewport: scaledViewport
  };
  
  // Очищаем canvas только если он уже был использован
  if (canvas.width > 0 && canvas.height > 0) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
  }
  
  try {
    await page.render(renderContext).promise;
  } catch (error) {
    if (error.message && error.message.includes('same canvas')) {
      // Игнорируем эту ошибку - она возникает при быстром перерисовывании
      console.log('Пропускаем рендеринг страницы', pageNum, 'из-за перезапуска');
    }
  }
}
// Рендерим все страницы - ПАРАЛЛЕЛЬНО КАК В РАБОЧЕМ КОДЕ
async function renderAllPages() {
  currentRenderId++;
  
  const renderId = currentRenderId;
  const promises = [];
  
  // Рендерим все страницы параллельно с небольшими задержками
  for (let i = 1; i <= pdfDoc.numPages; i++) {
    promises.push(new Promise(resolve => {
      setTimeout(async () => {
        if (renderId === currentRenderId) {
          await renderPage(i, renderId);
        }
        resolve();
      }, i * 10); // Задержка между запуском рендеринга страниц
    }));
  }
  
  await Promise.all(promises);
}

// Показываем индикатор зума
function showZoomIndicator() {
  zoomPercent.textContent = `${Math.round(zoom * 100)}%`;
  zoomIndicator.classList.add('visible');
  
  if (zoomIndicatorTimeout) {
    clearTimeout(zoomIndicatorTimeout);
  }
  
  zoomIndicatorTimeout = setTimeout(() => {
    zoomIndicator.classList.remove('visible');
  }, 1500);
}

// Применяем зум - ПРОСТАЯ ВЕРСИЯ
async function applyZoom(delta) {
  const newZoom = zoom + delta;
  
  if (newZoom < MIN_ZOOM || newZoom > MAX_ZOOM) {
    return;
  }
  
  zoom = parseFloat(newZoom.toFixed(2));
  
  // Показываем индикатор зума
  showZoomIndicator();
  
  await renderAllPages();
}

// Обновляем информацию о странице
function updatePageInfo() {
  if (!pdfDoc) return;
  
  const currentPage = getCurrentPage();
  pageInfo.textContent = `${currentPage} / ${pdfDoc.numPages}`;
}

// Получаем текущую страницу
function getCurrentPage() {
  if (!pdfDoc || canvases.length === 0) return 1;
  
  const scrollTop = wrapper.scrollTop;
  const wrapperHeight = wrapper.clientHeight;
  
  let currentPage = 1;
  let minDistance = Infinity;
  
  for (let i = 0; i < canvases.length; i++) {
    const canvas = canvases[i];
    const rect = canvas.getBoundingClientRect();
    const wrapperRect = wrapper.getBoundingClientRect();
    
    const canvasCenter = rect.top + rect.height / 2;
    const wrapperCenter = wrapperRect.top + wrapperHeight / 2;
    const distance = Math.abs(canvasCenter - wrapperCenter);
    
    if (distance < minDistance) {
      minDistance = distance;
      currentPage = i + 1;
    }
  }
  
  return currentPage;
}

// Прокрутка в начало
function scrollToTop() {
  wrapper.scrollTo({
    top: 0,
    behavior: 'smooth'
  });
}

// Прокрутка в конец
function scrollToBottom() {
  wrapper.scrollTo({
    top: wrapper.scrollHeight,
    behavior: 'smooth'
  });
}

// Настройка обработчиков событий
function setupEventListeners() {
  zoomInBtn.onclick = () => applyZoom(ZOOM_STEP);
  zoomOutBtn.onclick = () => applyZoom(-ZOOM_STEP);
  
  toTopBtn.onclick = scrollToTop;
  toBottomBtn.onclick = scrollToBottom;
  
  wrapper.addEventListener("scroll", () => {
    const scrollTop = wrapper.scrollTop;
    const scrollHeight = wrapper.scrollHeight - wrapper.clientHeight;
    
    if (scrollHeight > 0) {
      const progress = (scrollTop / scrollHeight * 100);
      progressBar.style.width = progress + "%";
      progressBar.style.transition = 'width 0.1s ease';
    }
    
    updatePageInfo();
  }, { passive: true });
  
  document.addEventListener('keydown', (e) => {
    if (e.ctrlKey) {
      if (e.key === '+' || e.key === '=') {
        e.preventDefault();
        applyZoom(ZOOM_STEP);
        return;
      }
      if (e.key === '-') {
        e.preventDefault();
        applyZoom(-ZOOM_STEP);
        return;
      }
    }
    
    switch(e.key) {
      case 'ArrowDown':
      case 'PageDown':
      case ' ':
        e.preventDefault();
        wrapper.scrollBy({ top: wrapper.clientHeight * 0.8, behavior: 'smooth' });
        break;
      case 'ArrowUp':
      case 'PageUp':
        e.preventDefault();
        wrapper.scrollBy({ top: -wrapper.clientHeight * 0.8, behavior: 'smooth' });
        break;
      case 'Home':
        e.preventDefault();
        scrollToTop();
        break;
      case 'End':
        e.preventDefault();
        scrollToBottom();
        break;
    }
  });
  
  let resizeTimeout;
  window.addEventListener('resize', () => {
    clearTimeout(resizeTimeout);
    resizeTimeout = setTimeout(async () => {
      if (pdfDoc) {
        await renderAllPages();
        updatePageInfo();
      }
    }, 250);
  });
  
  // Перетаскивание
  let isDragging = false;
  let startY = 0;
  let scrollTop = 0;
  
  wrapper.addEventListener('mousedown', (e) => {
    isDragging = true;
    startY = e.clientY;
    scrollTop = wrapper.scrollTop;
    wrapper.style.cursor = 'grabbing';
  });
  
  document.addEventListener('mousemove', (e) => {
    if (!isDragging) return;
    const walk = (startY - e.clientY) * 2;
    wrapper.scrollTop = scrollTop + walk;
  });
  
  document.addEventListener('mouseup', () => {
    isDragging = false;
    wrapper.style.cursor = 'grab';
  });
  
  // Тач события
  wrapper.addEventListener('touchstart', (e) => {
    if (e.touches.length === 1) {
      startY = e.touches[0].clientY;
      scrollTop = wrapper.scrollTop;
    }
  }, { passive: true });
  
  wrapper.addEventListener('touchmove', (e) => {
    if (e.touches.length === 1) {
      const walk = (startY - e.touches[0].clientY) * 2;
      wrapper.scrollTop = scrollTop + walk;
    }
  }, { passive: true });
}

// Инициализация
initPDF();

// Устанавливаем стили для открытия на всю страницу
document.addEventListener('DOMContentLoaded', function() {
  document.documentElement.style.overflow = 'hidden';
  document.body.style.overflow = 'hidden';
  
  // Убираем пробелы вокруг канвасов
  setTimeout(() => {
    if (wrapper) {
      wrapper.style.fontSize = '0';
      wrapper.style.lineHeight = '0';
      
      const allCanvas = wrapper.querySelectorAll('canvas');
      allCanvas.forEach(canvas => {
        canvas.style.margin = '0 auto';
        canvas.style.padding = '0';
        canvas.style.border = '0';
        canvas.style.display = 'block';
      });
    }
  }, 500);
});

// Обработка изменения размера окна
window.addEventListener('load', function() {
  // Принудительно устанавливаем комикс на весь экран
  reader.style.width = '100vw';
  reader.style.height = '100vh';
  reader.style.position = 'fixed';
  reader.style.top = '0';
  reader.style.left = '0';
  reader.style.zIndex = '9999';
  
  document.documentElement.style.overflow = 'hidden';
  document.body.style.overflow = 'hidden';
  
  // Рендерим заново после полной загрузки страницы
  setTimeout(() => {
    if (pdfDoc) {
      renderAllPages();
    }
  }, 100);
});
</script>
