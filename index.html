<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<meta name="viewport" 
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<title>Комикс</title>

<link rel="stylesheet" href="css/styles.css">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
<style>
/* ================= LOADING SCREEN ================= */
.loading-screen {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: #111;
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
  opacity: 1;
  transition: opacity 0.5s ease;
}

.loading-screen.hidden {
  opacity: 0;
  pointer-events: none;
}

.loading-content {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 20px;
}

.loading-spinner {
  width: 50px;
  height: 50px;
  border: 4px solid rgba(255, 255, 255, 0.1);
  border-top: 4px solid #FFA500;
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

.loading-text {
  color: #fff;
  font-size: 16px;
  font-family: 'Inter', sans-serif;
  font-weight: 500;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

/* Адаптивность для Loading Screen */
@media (max-width: 768px) {
  .loading-spinner {
    width: 40px;
    height: 40px;
    border-width: 3px;
  }
  
  .loading-text {
    font-size: 14px;
  }
}

@media (max-width: 480px) {
  .loading-spinner {
    width: 30px;
    height: 30px;
    border-width: 3px;
  }
  
  .loading-text {
    font-size: 13px;
  }
}
</style>
</head>

<body>

<!-- Loading Screen -->
<div class="loading-screen" id="loadingScreen">
  <div class="loading-content">
    <div class="loading-spinner"></div>
    <div class="loading-text">Загрузка комикса...</div>
  </div>
</div>

<div class="comic-reader" id="reader">
  <!-- Верхняя панель -->
  <div class="header-wrapper" id="headerWrapper">
    <div class="header">
      <div class="comic-title" id="comicTitle">Мой Комикс</div>
      <div class="header-page-info" id="headerPageInfo">– / –</div>
    </div>
  </div>

  <div class="canvas-wrapper" id="canvasWrapper"></div>

  <!-- Нижняя панель -->
  <div class="controls-wrapper" id="controlsWrapper">
    <div class="controls">
      <button id="toTop" class="nav-btn">▲</button>
      <button id="autoScroll" class="nav-btn auto-scroll-btn" title="Автоскролл">▽</button>
      <button id="toBottom" class="nav-btn">▼</button>
    </div>
  </div>

  <!-- Прогресс-бар -->
  <div class="progress">
    <div class="progress-bar" id="progressBar"></div>
  </div>
</div>

<script>
/* ================= КОНФИГ ================= */
const COMIC_PATH = 'https://bridgedannette-commits.github.io/my-comic/comics/test/';
const IMAGE_EXTS = ['webp', 'png', 'jpg', 'jpeg'];
const MAX_PAGES_SAFE = 500;
const isMobile = window.innerWidth <= 768;
const COMIC_TITLE = 'Мой Комикс'; // Название комикса

/* ================= СОСТОЯНИЕ ================= */
let pages = [];
const wrapper = document.getElementById('canvasWrapper');
const progressBar = document.getElementById('progressBar');
const headerWrapper = document.getElementById('headerWrapper');
const controlsWrapper = document.getElementById('controlsWrapper');
const comicTitle = document.getElementById('comicTitle');
const headerPageInfo = document.getElementById('headerPageInfo');
const reader = document.getElementById('reader');
const loadingScreen = document.getElementById('loadingScreen');

// Таймеры для скрытия панелей
let hidePanelsTimeout;
let panelsVisible = true;
const HIDE_PANELS_DELAY = 3000; // 3 секунды до скрытия

// Автоскролл
let autoScrollInterval = null;
const AUTO_SCROLL_SPEED = 150; // фиксированная скорость (пикселей в секунду)
let autoScrollActive = false;

/* ================= ФУНКЦИИ ДЛЯ ПАНЕЛЕЙ ================= */
function showPanels() {
  if (!panelsVisible) {
    headerWrapper.classList.remove('hidden');
    controlsWrapper.classList.remove('hidden');
    reader.classList.remove('panels-hidden');
    reader.classList.add('panels-visible');
    panelsVisible = true;
  }
  resetHidePanelsTimer();
}

function hidePanels() {
  if (panelsVisible) {
    headerWrapper.classList.add('hidden');
    controlsWrapper.classList.add('hidden');
    reader.classList.remove('panels-visible');
    reader.classList.add('panels-hidden');
    panelsVisible = false;
  }
}

function resetHidePanelsTimer() {
  clearTimeout(hidePanelsTimeout);
  hidePanelsTimeout = setTimeout(hidePanels, HIDE_PANELS_DELAY);
}

function togglePanels() {
  if (panelsVisible) {
    hidePanels();
  } else {
    showPanels();
  }
}

/* ================= ФУНКЦИИ АВТОСКРОЛЛА ================= */
function startAutoScroll() {
  if (autoScrollInterval) {
    clearInterval(autoScrollInterval);
  }
  
  autoScrollActive = true;
  updateAutoScrollButton();
  
  autoScrollInterval = setInterval(() => {
    const currentScroll = wrapper.scrollTop;
    const maxScroll = wrapper.scrollHeight - wrapper.clientHeight;
    
    // Если достигли конца, останавливаем автоскролл
    if (currentScroll >= maxScroll - 1) {
      stopAutoScroll();
      return;
    }
    
    // Плавный скролл с фиксированной скоростью
    const scrollAmount = AUTO_SCROLL_SPEED / 60; // делим на 60 кадров в секунду
    wrapper.scrollBy({ top: scrollAmount, behavior: 'instant' });
    
    // Если достигли конца после скролла
    if (wrapper.scrollTop >= maxScroll - 1) {
      stopAutoScroll();
    }
  }, 1000 / 60); // 60 FPS
}

function stopAutoScroll() {
  if (autoScrollInterval) {
    clearInterval(autoScrollInterval);
    autoScrollInterval = null;
  }
  autoScrollActive = false;
  updateAutoScrollButton();
}

function toggleAutoScroll() {
  if (autoScrollActive) {
    stopAutoScroll();
  } else {
    startAutoScroll();
  }
  showPanels();
}

function updateAutoScrollButton() {
  const autoScrollBtn = document.getElementById('autoScroll');
  if (autoScrollActive) {
    autoScrollBtn.innerHTML = '■';
    autoScrollBtn.classList.add('active');
    autoScrollBtn.title = 'Автоскролл - нажмите для остановки';
  } else {
    autoScrollBtn.innerHTML = '▽';
    autoScrollBtn.classList.remove('active');
    autoScrollBtn.title = 'Автоскролл - нажмите для начала';
  }
}

/* ================= ЗАГРУЗКА КОМИКСА ================= */
async function imageExists(url) {
  try {
    const res = await fetch(url, { method: 'HEAD', cache: 'no-store' });
    return res.ok;
  } catch {
    return false;
  }
}

async function detectPages() {
  const result = [];
  let pageNum = 1;

  while (pageNum <= MAX_PAGES_SAFE) {
    let found = false;

    for (const ext of IMAGE_EXTS) {
      const url = `${COMIC_PATH}${pageNum}.${ext}`;
      if (await imageExists(url)) {
        result.push({ url, num: pageNum });
        found = true;
        break;
      }
    }

    if (!found) break;
    pageNum++;
  }

  return result;
}

async function loadComic() {
  // Показываем loading screen
  loadingScreen.classList.remove('hidden');
  
  wrapper.innerHTML = '<div style="color:#ccc;text-align:center;padding:50px;">Загрузка...</div>';
  
  pages = await detectPages();
  
  if (pages.length === 0) {
    wrapper.innerHTML = '<div style="color:#fff;text-align:center;padding:50px;">Комикс не найден</div>';
    // Скрываем loading screen при ошибке
    setTimeout(() => {
      loadingScreen.classList.add('hidden');
    }, 500);
    return;
  }
  
  wrapper.innerHTML = '';
  
  pages.forEach((page, index) => {
    const container = document.createElement('div');
    container.className = 'page-container';
    container.dataset.page = page.num;
    container.style.margin = '0 auto';
    
    const img = document.createElement('img');
    img.loading = 'lazy';
    img.draggable = false;
    img.alt = `Страница ${page.num}`;
    img.style.display = 'block';
    img.style.margin = '0 auto';
    img.style.maxWidth = '100%';
    img.style.height = 'auto';
    
    // Автоматический размер
    img.onload = function() {
      const maxWidth = isMobile ? 
        Math.min(800, window.innerWidth - 20) : 
        Math.min(1000, window.innerWidth * 0.95);
      
      if (this.naturalWidth > maxWidth) {
        const scale = maxWidth / this.naturalWidth;
        this.style.width = maxWidth + 'px';
        this.style.height = (this.naturalHeight * scale) + 'px';
        container.style.width = maxWidth + 'px';
      } else {
        this.style.width = this.naturalWidth + 'px';
        container.style.width = this.naturalWidth + 'px';
      }
    };
    
    if (index < 5) {
      img.src = page.url;
    } else {
      img.dataset.src = page.url;
    }
    
    container.appendChild(img);
    wrapper.appendChild(container);
  });
  
  // Устанавливаем название комикса
  comicTitle.textContent = COMIC_TITLE;
  
  // Инициализируем состояние панелей
  reader.classList.add('panels-visible');
  
  updatePageInfo();
  
  // Ждем загрузки всех изображений
  const images = wrapper.querySelectorAll('img');
  let loadedCount = 0;
  
  if (images.length === 0) {
    setTimeout(() => {
      loadingScreen.classList.add('hidden');
    }, 300);
  } else {
    images.forEach(img => {
      if (img.complete) {
        loadedCount++;
        checkAllImagesLoaded(loadedCount, images.length);
      } else {
        img.addEventListener('load', () => {
          loadedCount++;
          checkAllImagesLoaded(loadedCount, images.length);
        });
        img.addEventListener('error', () => {
          loadedCount++;
          checkAllImagesLoaded(loadedCount, images.length);
        });
      }
    });
  }
  
  setTimeout(() => {
    wrapper.querySelectorAll('img[data-src]').forEach(img => {
      img.src = img.dataset.src;
      delete img.dataset.src;
    });
  }, 100);
}

function checkAllImagesLoaded(loaded, total) {
  if (loaded === total) {
    setTimeout(() => {
      loadingScreen.classList.add('hidden');
    }, 300);
  }
}

/* ================= НАВИГАЦИЯ ================= */
function getCurrentPage() {
  const containers = wrapper.querySelectorAll('.page-container');
  if (containers.length === 0) return 1;
  
  const wrapperRect = wrapper.getBoundingClientRect();
  const wrapperCenter = wrapperRect.top + wrapperRect.height / 2;
  
  let currentPage = 1;
  let minDistance = Infinity;
  
  containers.forEach(container => {
    const rect = container.getBoundingClientRect();
    const containerCenter = rect.top + rect.height / 2;
    const distance = Math.abs(containerCenter - wrapperCenter);
    
    if (distance < minDistance) {
      minDistance = distance;
      currentPage = parseInt(container.dataset.page) || 1;
    }
  });
  
  return currentPage;
}

function updatePageInfo() {
  const current = getCurrentPage();
  headerPageInfo.textContent = `${current} / ${pages.length}`;
}

function updateScrollInfo() {
  const scrollHeight = wrapper.scrollHeight - wrapper.clientHeight;
  if (scrollHeight > 0) {
    const progress = (wrapper.scrollTop / scrollHeight) * 100;
    progressBar.style.width = progress + '%';
  }
  updatePageInfo();
}

/* ================= СОБЫТИЯ ================= */
document.getElementById('toTop').onclick = () => {
  wrapper.scrollTo({ top: 0, behavior: 'smooth' });
  stopAutoScroll(); // Останавливаем автоскролл при навигации
  showPanels();
};

document.getElementById('toBottom').onclick = () => {
  wrapper.scrollTo({ top: wrapper.scrollHeight, behavior: 'smooth' });
  stopAutoScroll(); // Останавливаем автоскролл при навигации
  showPanels();
};

document.getElementById('autoScroll').onclick = () => {
  toggleAutoScroll();
};

// Клик по области комикса показывает/скрывает панели (НЕ останавливает автоскролл)
wrapper.addEventListener('click', (e) => {
  // Не реагируем на клики по кнопкам и другим интерактивным элементам
  if (e.target.tagName === 'BUTTON' || e.target.closest('button')) {
    return;
  }
  
  // Не реагируем на клики по прогресс-бару
  if (e.target.closest('.progress')) {
    return;
  }
  
  togglePanels();
});

// Тап на мобильных устройствах (для touch устройств)
wrapper.addEventListener('touchstart', (e) => {
  // Сохраняем начальную точку тапа
  e.tapStartX = e.touches[0].clientX;
  e.tapStartY = e.touches[0].clientY;
  e.isTap = true;
}, { passive: true });

wrapper.addEventListener('touchmove', (e) => {
  // Если палец сдвинулся больше чем на 10px - это не тап, а свайп
  const touch = e.touches[0];
  const diffX = Math.abs(touch.clientX - e.tapStartX);
  const diffY = Math.abs(touch.clientY - e.tapStartY);
  
  if (diffX > 10 || diffY > 10) {
    e.isTap = false;
  }
}, { passive: true });

wrapper.addEventListener('touchend', (e) => {
  // Если это был тап (не свайп) - показываем/скрываем панели
  if (e.isTap) {
    // Не реагируем на тапы по кнопкам
    const target = e.target;
    if (target.tagName === 'BUTTON' || target.closest('button')) {
      return;
    }
    
    // Не реагируем на тапы по прогресс-бару
    if (target.closest('.progress')) {
      return;
    }
    
    togglePanels();
    e.preventDefault();
  }
}, { passive: false });

// При скролле колесиком мыши - НЕ показываем панели, только обновляем прогресс
let scrollTimeout;
wrapper.addEventListener('scroll', () => {
  const scrollHeight = wrapper.scrollHeight - wrapper.clientHeight;
  if (scrollHeight > 0) {
    const progress = (wrapper.scrollTop / scrollHeight) * 100;
    progressBar.style.width = progress + '%';
  }
  
  clearTimeout(scrollTimeout);
  scrollTimeout = setTimeout(updatePageInfo, 50);
}, { passive: true });

// Ресайз окна
let resizeTimeout;
window.addEventListener('resize', () => {
  clearTimeout(resizeTimeout);
  resizeTimeout = setTimeout(() => {
    const maxWidth = isMobile ? 
      Math.min(800, window.innerWidth - 20) : 
      Math.min(1000, window.innerWidth * 0.95);
    
    wrapper.querySelectorAll('img').forEach(img => {
      if (img.naturalWidth) {
        if (img.naturalWidth > maxWidth) {
          const scale = maxWidth / img.naturalWidth;
          img.style.width = maxWidth + 'px';
          img.style.height = (img.naturalHeight * scale) + 'px';
          
          const container = img.parentElement;
          if (container) {
            container.style.width = maxWidth + 'px';
          }
        }
      }
    });
    
    updatePageInfo();
  }, 250);
});

// Клавиатура
document.addEventListener('keydown', (e) => {
  switch(e.key) {
    case 'ArrowDown':
    case 'PageDown':
    case ' ':
      e.preventDefault();
      wrapper.scrollBy({ top: wrapper.clientHeight * 0.8, behavior: 'smooth' });
      stopAutoScroll(); // Останавливаем автоскролл при ручной навигации
      break;
    case 'ArrowUp':
    case 'PageUp':
      e.preventDefault();
      wrapper.scrollBy({ top: -wrapper.clientHeight * 0.8, behavior: 'smooth' });
      stopAutoScroll(); // Останавливаем автоскролл при ручной навигации
      break;
    case 'Home':
      e.preventDefault();
      wrapper.scrollTo({ top: 0, behavior: 'smooth' });
      stopAutoScroll();
      break;
    case 'End':
      e.preventDefault();
      wrapper.scrollTo({ top: wrapper.scrollHeight, behavior: 'smooth' });
      stopAutoScroll();
      break;
    case 'a':
    case 'A':
      // Клавиша A для включения/выключения автоскролла
      e.preventDefault();
      toggleAutoScroll();
      break;
    case 'f':
    case 'F':
      // Клавиша F для переключения видимости панелей
      e.preventDefault();
      togglePanels();
      break;
  }
});

// При бездействии скрываем панели
resetHidePanelsTimer();

/* ================= ЗАПУСК ================= */
document.addEventListener('DOMContentLoaded', () => {
  // Фикс для мобильных
  if (/iPhone|iPad|iPod/i.test(navigator.userAgent)) {
    document.documentElement.style.height = '-webkit-fill-available';
    document.getElementById('reader').style.height = '-webkit-fill-available';
  }
  
  // Блокируем скролл страницы
  document.documentElement.style.overflow = 'hidden';
  document.body.style.overflow = 'hidden';
  
  // Загружаем комикс
  loadComic();
});

// После полной загрузки
window.addEventListener('load', () => {
  setTimeout(updatePageInfo, 100);
});

// Скрываем loading screen через 10 секунд максимум (на всякий случай)
setTimeout(() => {
  if (loadingScreen && !loadingScreen.classList.contains('hidden')) {
    loadingScreen.classList.add('hidden');
  }
}, 10000);
</script>
</body>
</html>
